# 10 社交网络
## 10.2 社交网络的聚类分析
### 10.2.1 社交网络的距离量度
### 10.2.2 标准的聚类方法
点分配法：
* 假设用k-means 算法聚类， 选k=2, 随机选一个点，以这个点创建一个类，在选择一个离他最远的点作为另一个类，这个点选得约晚越好。
*
### 10.2.3 中间性
* 中间性指的是一条边多大程度处在两个聚类之间，成为这两个聚类的桥梁。
* 一条边的中间性值越大，说明有越多的任意两点，他们之间要走捷径就必须通过这个edge(a, b)。
	* 这样的成对节点的数目就是Betweenness值
	* 经过edge(a, b)的最短路径不止一条的，按相同最短路径的数量作为分母算个比例记入edge(a, b) 的betweenness
### 10.2.4 Girvan-Newman 算法
* 为了计算所有边的Betweenness，我们需要为每条边计算通过它们的最短路径（捷径）的数量。这里一斤（GN）算法
* 为了计算一条边的Betweenness值，访问每个节点，统计从该节点开始到其它所有节点的最短路径中通过这条边的次数。
* GN算法由breadth-first search（BFS）算法开始:
	1. 从节点X开始，每个节点的level记录为其到X的最短距离的长度。
		* 跨level级别的边称为DAG（directed, acyclic graph)
		* 靠近root节点的Y为父节点，Z为子节点。
		* 用实线代表DAG， 虚线代表同级别节点的连线
	2. 第二步用到达root可供选择的最短路径的数量来标记每个节点
		1. 选E为root，其标记为1
		2. 一级有D，F 他们只有一个父节点E，最短路径条数为1，标记为1
		3. B，G在level2，B只有一个父节点D，所以最短路径跟其父节点一样为1
		4. G有两个父节点D，F 所以最短路径条数为父节点标记之和=2
		5. 最后，A，C到root的距离为3，在level3，他们都只有父节点B，所以标记1
	3. 最后一步
		1. 每个叶子（in DAG）得1分
		2. 不是叶子的得1分+其到下一个Leve的DAG edge的分数之和
		3. 一个DAG edge(Y, Z) 的分值为其下一级节点Z的分值的一部分，其占比是根节点到这个节点Y的最短路径数/根节点到Z的所有父节点最短路径数之和。

### 10.2.5 使用betweenness 来发现社群
* 在节点图上，逐步增加edge，从betweenness 小的开始增加，允许的Betweenness越大，就会产生越大的社群。
 * 更常见的是移出edge的方法，从Betweenness最高的edge开始去掉直到合适为止。
